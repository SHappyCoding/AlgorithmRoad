背包问题；
0-1背包：
最优子结构：重量至多为W磅的最值钱的一包东西设为集合S，假设从中拿掉物品j，余下的就是集合S-j，这个集合一定是从初j物品之外n-1件所构成的，这个集合代表是重量至多为W-wj磅的最值钱的一包东西。
dp[i\][j\]=Max(dp[i-1\][j-w[i]\]+v[i]，dp[i-1\][j])
空间优化：前 i 件物品的状态仅与前 i-1 件物品的状态有关，即dp[i\][..]时，只与dp[i-1\][..]有关。因为 dp[j-w] 表示 dp[i-1\][j-w]，因此不能先求 dp[i\][j-w]，防止将 dp[i-1\][j-w] 覆盖。
也就是说要先计算 dp[i\][j] 再计算 dp[i\][j-w]，在程序实现时需要按倒序来循环求解。
部分背包：
最优子结构：设最优货物集合为S，去掉某物品j的重量w，则余下的货物是可以从n-1件原有物品和j物品的wj-w磅中可带走的集合S-w，重量至多为W-w的最值钱的东西。
同时这个问题是具有贪心选择性质的，可以直接用贪心选择即可。
这里的方法和活动选择算法是一样的。


任务调度：
最优调度S表示为：早任务集+迟任务集的排列
早任务集规定按期限的单调递增顺序对造任务进行调度，迟任务集可以按任意次序。
独立性函数：IsIndependent(ArrayList<Tasknode> PreScheduling,int len)
1、开辟一个数组C保存早任务集(需要判断的)中元素的的deadline。
2、如果有一个元素deadline为1则C[1]++.
3、重新对C[i]赋值，C[i]为前面元素之和，现在判断C[i]>i表示i之前完成的任务个数大于i，所以这肯定是不独立的，返回false
4、如果所有取值t都有C[i]≤i，则返回true
