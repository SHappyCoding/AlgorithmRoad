堆：
是一个数组对象，被视为一颗完全二叉树。表示堆的数组A有两个属性：length[A]表示数组中元素个数，heap-size[A]表示数组堆的元素个数，
也就是说A[heap-size[A]]之后都不是堆中的元素个数(算法导论中默认下标从1开始，我写的算法下标从0开始)。树根为A[1]。

大根堆：除了根以外的结点i，有A[PARENT[i]]≥A[i]，即结点值都小于等于父结点值，这样，堆的最大值就存在根中。小根堆相反。

函数：
MAX-HEAPIFY(A，i):
保持堆性质函数。A表示数组，i表示下标。调用这个函数就是A[i]值破坏了大根堆性质，假定LEFT(i)，RIGHT(i)为根的子树都是大根堆。
时间复杂度：O(h)h为调用结点的高度
算法流程：
1、比较A[LEFT(i)]，A[RIGHT(i)]，A[i]三个值，最大值下标保存为largest
2、如果i=largest，算法结束
3、否则，交换A[i]与A[largest]，递归调用MAX-HEAPIFY(A，largest)

BUILD-MAX-HEAP(A):
建堆。子数组A[n/2+1..n]都是树中叶子，n表示数组长度。叶子都可以看做是只含一个元素的大根堆，所以从数组下标n/2开始，调用MAX_HEAPIFY(A,i)函数建堆即可。
时间复杂度：O(n)
算法流程：
1、从非叶结点调用MAX_HEAPIFY()来保持堆性质。

HEAPSRORT(A):
堆排序。每次交换A[1]和A[heap-size[A]]的值，heap-size[A]--，由于A[Heap_size]变成了根结点破坏了大根堆性质，
所以调用MAX_HEAPIFY(A，1)来保持堆。堆的大小由heap-size[A]到1。
时间复杂度：O(nlgn)
算法流程：
1、交换A[1]和A[heap-size[A]]，heap-size[A]--
2、调用MAX_HEAPIFY(A，0)
