堆：
是一个数组对象，被视为一颗完全二叉树。表示堆的数组A有两个属性：length[A]表示数组中元素个数，heap-size[A]表示数组堆的元素个数，
也就是说A[heap-size[A]]之后都不是堆中的元素个数(算法导论中默认下标从1开始，我写的算法下标从0开始)。树根为A[1]。

大根堆：除了根以外的结点i，有A[PARENT[i]]≥A[i]，即结点值都小于等于父结点值，这样，堆的最大值就存在根中。小根堆相反。

函数：
MAX-HEAPIFY(A，i):
保持堆性质函数。A表示数组，i表示下标。调用这个函数就是A[i]值破坏了大根堆性质，假定LEFT(i)，RIGHT(i)为根的子树都是大根堆。
时间复杂度：O(h)h为调用结点的高度
算法流程：
1、比较A[LEFT(i)]，A[RIGHT(i)]，A[i]三个值，最大值下标保存为largest
2、如果i=largest，算法结束
3、否则，交换A[i]与A[largest]，递归调用MAX-HEAPIFY(A，largest)

BUILD-MAX-HEAP(A):
建堆。子数组A[n/2+1..n]都是树中叶子，n表示数组长度。叶子都可以看做是只含一个元素的大根堆，所以从数组下标n/2开始，调用MAX_HEAPIFY(A,i)函数建堆即可。
时间复杂度：O(n)
算法流程：
1、从非叶结点调用MAX_HEAPIFY()来保持堆性质。

HEAPSRORT(A):
堆排序。每次交换A[1]和A[heap-size[A]]的值，heap-size[A]--，由于A[Heap_size]变成了根结点破坏了大根堆性质，
所以调用MAX_HEAPIFY(A，1)来保持堆。堆的大小由heap-size[A]到1。
时间复杂度：O(nlgn)
算法流程：
1、交换A[1]和A[heap-size[A]]，heap-size[A]--
2、调用MAX_HEAPIFY(A，0)


以下的函数用来实现最大优先级队列：最大优先级队列的一个应用是在一台分时计算机上进行作业调度，这种队列对要执行的个作业及他们之间的相对优先关系加以记录。
堆来实现优先级队列时，需要在堆的每个元素里存储对应的应用对象的炳。对象炳的准确表示到底是怎样(如，一个指针，一个整型数等等)还取决于具体的应用。这里对象炳用数组下标表示。

Heap_Maximum(A):仅弹出最大优先级作业对象
Heap_Extract_max(A):执行最大优先级作业，并从堆中弹出
Heap_increase_key(A，i，key):需要将队列元素的优先级增大，也就是增加值
Max_Heap_insert(A,key):模拟队列中需要插入一个元素

Heap_Maximum(A):
返回堆最大值。
时间复杂度：O(1)

Heap_Extract_max(A):
去掉堆中最大值并返回。堆中最大值返回后，最大值就不在堆里面了，也不在数组里面了。
时间复杂度：O(lgn)
算法流程：
1、弹出堆顶，将A[0]赋值为A[heap-size[A]]。
2、调用MAX_HEAPIFY(A，0)，调整堆。


Heap_increase_key(A，i，key):
增大元素值。key一定大于A[i]，关键字值需要增加的元素由数组下标i标识，A[i]赋值为key之后可能破坏最大堆性质。从本结点往根结点移动的路径上，为新增大的关键字寻找合适的位置。
时间复杂度：O(lgn)
算法流程：
1、A[i]赋值为key。向上移动
2、大于父结点继续向上移动，小于父结点此时最大堆性质成立。

Max_Heap_insert(A,key):
插入一个元素。首先加入一个关键字值为负无穷的叶结点来扩展最大堆，然后来设置新节点的关键字的正确值，并保持最大堆性质。
时间复杂度：O(lgn)
算法流程：
1、Heap_siez[A]++
2、A[Heap_siez[A]]赋值为负无穷
3、调用Heap_increase_key(A，Heap_siez[A]，key)调整堆





